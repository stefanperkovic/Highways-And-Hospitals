Name: Stefan Perkovic

| Date   |           Time           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Update |
|:-------|:------------------------:|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:| 
| Sep 11 |       5:40 - 6:10        | I started thinking about how to approach the problem set. I decided that it would be nice if we could get rid of the extraneous solution when hospitals are cheaper than highways at the start. However, I realized I couldn't just multiple hospitalCost * cities.length because the cities function is the highway links, so I have left it their for now but will change later. Afterwards I decided that it would be simpler to check if their was a connection between cities if we just had a boolean array that would tells us so I made that. |
| Sep 11 |       6:25 - 6:55        |                                                                                  When I look back at the assignment graph you can see too separate entities of cities. It would be best to detect these components and then treat them separately as you can't build highways between them. I decided that DFS would make sense here as you start at one node and go through all its connections that haven't been visited to create a section. Using a stack here makes sense as you go to the closest connections first and don't skip connections. |
| Sep 12 |       8:50 - 9:20        |                                                                                                    I worked with Isha and Kieran on triyng to come up with the opitimal way to solve the problem set. We discussed how we should divide into subtrees build only 1 hopsital in each and the amount of cities - 1 is how many highways we need to build. We can store this information in a ArrayList and do simple arithemtic in the end to find the total cost. We can do either DFS or BFS and keep track of whats been visited to no double count. |
| Sep 12 |       5:45 - 6:15        |                                                                                                                                                  After having our lecture on union find I started to work on implementing the algorithm. I first fixed the edge case of hospitals being cheaper than highways to just multiply by n the amount of cities. Then I create a roots array to store all the cities roots. I looped through each city making sure not to override any previous roots. I then made the 1st node the root of the second node. |
| Sep 12 |       6:15 - 6:45        |                                  I looked through my array of roots and as we did on the worksheet if an entry was a zero or "blank" I added one. Then I did the equation that we did on the worksheet below. After testing I realized that I wasn't going deeper into the roots as I was supposed to. I would only get the first root not the one after that. I created two while loops to go through and go through the current cities roots to find the last one. Then I made that the city I would make the root of the root of the first number. |
| Sep 19 | 15min class + 15min free |                                                                                                                                                                                I worked on implementing the path compressions as described in our lecture. I created a new variable x and looped through it along with city1. I did the same thing for the second city with a new variable z. Although their are now 4 while loops in total they will run less times then the other two combined. This should make the algorithm run slightly faster. |
| Sep 22 |         1:30 - 2         |                                                                                            When looking through the path compression, I didn't see why we needed two while loops per root. I decided to combine them into one and do the path compression at the same time as assigning roots as this should make it more efficient as long as it works. I changed the counting subgraphs to check for negative numbers as they will indicate disconected subtrees after weight balancing. I start too think about how to implement weight balancing. |
| Sep 22 |        2:00-2:45         |                                                                                                I am struggling to get path compression too work along side weight balancing. I can't get it too pass the tests and my logic is clearly wrong, but im not sure how. I think that each time you join to subgraphs you have to -1 to account for the additonal vertice added, but it doesn't seems to be implenting correctly. I also got rid of the one while loop approach for now because I was getting wrong results and index-out of bounds errors. |
| Sep 22 |        9:30 - 10         |                                                                                                                                                                                                                                              Put the union into a separate function. Realize I had just a mistype in the while loop causing error. This makes the code easier to read and also I can reuse the function. Used the logic I knew previously but made sure to change the sign so that root1<root2 because they will be cast as negative. |
| Sep 22 |        10 - 10:30        |                                                                                                                                                                            Created a function find so that I can re-use the find function as I was doing the same two while loops twice for both root1 and root2. Changed subgraph calculation so that I didn't have to loop in the end making the code more efficient. Instead I track each time we merge two roots as that decreases the amount of subgraphs and start by initializing n subgraphs. |


To add a new row to the table, click into a cell and then hit shift-enter.